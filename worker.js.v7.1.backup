/**
 * WEBZYL WORKER v7.1 - CEO DASHBOARD + CORS FIX
 * 
 * NEW in v7.1:
 * - Fixed CORS for X-CEO-Token header
 * - CEO APIs now accessible from dashboard
 * 
 * NEW in v7.0:
 * - CEO Dashboard APIs with token authentication
 * - Property onboarding (template + AI enhancement)
 * - Index-based property listing (scalable to 100K+)
 * - Gemini AI integration for quality content
 * 
 * NEW in v6.4.0:
 * - Conditional WhatsApp API: Only send when user hasn't initiated WhatsApp
 * - Quota optimization: 40-60% reduction in WhatsApp API usage
 * - Smart notification routing based on user behavior
 * 
 * NEW in v6.3.3:
 * - Fixed route order: Data endpoints checked BEFORE subdomain routing
 * 
 * NEW in v6.3.2:
 * - Data endpoint: /data/:slug.json for Pages JavaScript
 * 
 * Architectural Principles:
 * 1. Worker is a ROUTER, not an HTML processor
 * 2. KV is the authoritative source of truth
 * 3. Pages is the rendering service
 * 4. Keep coupling loose, complexity low
 * 
 * Routes:
 * - *.webzyl.com (custom subdomains) â†’ NEW
 * - /api/admin/publish
 * - /api/config/:slug
 * - /api/booking
 * - /api/operator/*
 */

import { handleBookingRequest } from './Booking_Enquiry/files/booking-api.js';

// Reserved subdomains that customers cannot use
const RESERVED_SUBDOMAINS = [
  'www', 'api', 'admin', 'operator', 'dashboard',
  'app', 'cdn', 'assets', 'static', 'staging', 'dev'
];

// Slug validation pattern
const VALID_SLUG_PATTERN = /^[a-z0-9-]{3,30}$/;

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const hostname = url.hostname;
    const path = url.pathname;
    
    // =====================================================
    // AUTOMATIC SUBDOMAIN ROUTING (Core Feature)
    // =====================================================
    
    // CRITICAL: Check for /data/*.json FIRST before subdomain routing
    // Otherwise subdomain routing will catch it and forward to Pages
    if (path.startsWith('/data/') && path.endsWith('.json')) {
      const slug = path.split('/')[2].replace('.json', '');
      console.log(`[DATA] Request for: ${slug}`);
      return handleDataRequest(slug, env);
    }
    
    const propertySlug = extractPropertySlug(hostname);
    
    if (propertySlug) {
      console.log(`[SUBDOMAIN] Detected property: ${propertySlug}`);
      return await handlePropertyRequest(propertySlug, path, request, env);
    }
    
    // =====================================================
    // CORS Preflight (with CEO Token support)
    // =====================================================
    
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        status: 204,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-CEO-Token',
          'Access-Control-Max-Age': '86400'
        }
      });
    }
    
    // =====================================================
    // OPERATOR DASHBOARD APIs
    // =====================================================
    
    if (path === '/api/operator/login' && request.method === 'GET') {
      return handleOperatorLogin(request, env);
    }
    
    if (path.startsWith('/api/operator/dashboard/')) {
      const operatorSlug = path.split('/')[4];
      return handleOperatorDashboard(operatorSlug, env);
    }
    
    if (path.startsWith('/api/operator/update/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[4];
      return handleOperatorUpdate(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/bookings/')) {
      const operatorSlug = path.split('/')[4];
      return handleOperatorBookings(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/gallery/upload/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[5];
      return handleGalleryUpload(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/gallery/update/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[5];
      return handleGalleryUpdate(request, env, operatorSlug);
    }
    
    // =====================================================
    // EXISTING APIs (v6.2.2 compatibility)
    // =====================================================
    
    if (path === '/api/admin/publish' && request.method === 'POST') {
      return handlePublish(request, env);
    }
    
    if (path.startsWith('/api/config/')) {
      const configSlug = path.split('/').pop();
      return handleGetConfig(configSlug, env);
    }
    
    if (path === '/api/booking') {
      return handleBookingRequest(request, env, ctx);
    }
    
    // =====================================================
    // CEO DASHBOARD APIs (v7.0)
    // =====================================================
    
    // CEO Token Validation
    function validateCEOToken(request, env) {
      const token = request.headers.get('X-CEO-Token');
      if (!token || token !== env.CEO_TOKEN) {
        return false;
      }
      return true;
    }
    
    if (path === '/api/ceo/generate' && request.method === 'POST') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ status: 'error', message: 'Unauthorized' }, 403);
      }
      return handleCEOGenerate(request, env);
    }
    
    if (path === '/api/ceo/enhance' && request.method === 'POST') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ status: 'error', message: 'Unauthorized' }, 403);
      }
      return handleCEOEnhance(request, env);
    }
    
    if (path === '/api/ceo/publish' && request.method === 'POST') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ status: 'error', message: 'Unauthorized' }, 403);
      }
      return handleCEOPublish(request, env);
    }
    
    if (path === '/api/ceo/properties' && request.method === 'GET') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ status: 'error', message: 'Unauthorized' }, 403);
      }
      return handleCEOProperties(env);
    }
    
    if (path.startsWith('/s/')) {
      const ssrSlug = path.split('/')[2];
      return handleWebsiteSSR(ssrSlug, env);
    }
    
    // Root status
    if (path === '/') {
      return jsonResponse({
        status: 'ok',
        service: 'webzyl-worker',
        version: '7.1',
        architecture: 'worker_as_router',
        features: {
          automatic_subdomains: 'slug.webzyl.com',
          data_endpoints: '/data/:slug.json',
          ceo_dashboard: '/api/ceo/* (token protected, CORS enabled)',
          conditional_whatsapp: 'quota optimization enabled',
          operator_dashboard: '/api/operator/*',
          kv_authority: 'config:{slug} is source of truth'
        }
      });
    }
    
    return new Response('Not Found', { status: 404 });
  }
};

// ============================================================================
// SUBDOMAIN ROUTING - Core Logic
// ============================================================================

/**
 * Extract property slug from hostname
 * Returns null if not a property subdomain
 */
function extractPropertySlug(hostname) {
  // Only process *.webzyl.com subdomains
  if (!hostname.endsWith('.webzyl.com')) {
    return null;
  }
  
  // Exclude root domain
  if (hostname === 'webzyl.com' || hostname === 'www.webzyl.com') {
    return null;
  }
  
  // Exclude reserved subdomains
  const subdomain = hostname.split('.')[0];
  if (RESERVED_SUBDOMAINS.includes(subdomain)) {
    return null;
  }
  
  // Validate slug format
  if (!VALID_SLUG_PATTERN.test(subdomain)) {
    return null;
  }
  
  return subdomain;
}

/**
 * Handle property website requests
 * This is the ROUTER - it validates and forwards, does NOT process HTML
 */
async function handlePropertyRequest(slug, path, request, env) {
  try {
    // =====================================================
    // AUTHORITATIVE CHECK
    // KV is the single source of truth
    // A property exists IFF this returns valid config
    // =====================================================
    
    const configKey = `config:${slug}`;
    const configRaw = await env.RESORT_CONFIGS.get(configKey);
    
    if (!configRaw) {
      console.log(`[PROPERTY] Not found: ${slug}`);
      return propertyNotFoundResponse(slug);
    }
    
    // Parse config to check status
    let config;
    try {
      config = JSON.parse(configRaw);
    } catch (error) {
      console.error(`[PROPERTY] Invalid JSON for ${slug}:`, error);
      return new Response('Internal Server Error', { status: 500 });
    }
    
    // =====================================================
    // SOFT-DELETE PATTERN
    // Better SEO and support workflows
    // =====================================================
    
    if (config.deleted === true) {
      console.log(`[PROPERTY] Deleted: ${slug}`);
      return propertyDeletedResponse(slug);
    }
    
    // Check active status
    if (config.status !== 'active') {
      console.log(`[PROPERTY] Inactive: ${slug} (status: ${config.status})`);
      return propertyInactiveResponse(slug, config.status);
    }
    
    // =====================================================
    // MAINTENANCE MODE
    // =====================================================
    
    if (config.maintenance === true) {
      console.log(`[PROPERTY] Maintenance: ${slug}`);
      return propertyMaintenanceResponse(slug);
    }
    
    // =====================================================
    // FORWARD TO PAGES (Router Pattern)
    // Worker does NOT process HTML
    // Worker does NOT parse response
    // Worker simply forwards validated requests
    // =====================================================
    
    console.log(`[PROPERTY] Routing to Pages: ${slug}${path}`);
    
    return await forwardToPages(slug, path, request, env);
    
  } catch (error) {
    console.error(`[PROPERTY] Error handling ${slug}:`, error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

/**
 * Forward request to Pages rendering service
 * IMPORTANT: This is a transparent proxy, NOT an HTML processor
 */
async function forwardToPages(slug, path, originalRequest, env) {
  try {
    // Construct Pages URL
    // Note: This couples to Pages structure - document this clearly
    const pagesBaseUrl = 'https://webzyl-sites.pages.dev';
    const pagesUrl = `${pagesBaseUrl}/${slug}${path || ''}`;
    
    console.log(`[FORWARD] ${pagesUrl}`);
    
    // Create new request preserving original headers
    const pagesRequest = new Request(pagesUrl, {
      method: originalRequest.method,
      headers: originalRequest.headers,
      body: originalRequest.body,
      redirect: 'follow'
    });
    
    // Fetch from Pages
    const pagesResponse = await fetch(pagesRequest);
    
    // =====================================================
    // ROUTER PATTERN: Forward response as-is
    // Do NOT parse HTML
    // Do NOT modify body
    // Do preserve caching headers
    // =====================================================
    
    // Clone response to modify only headers
    const response = new Response(pagesResponse.body, {
      status: pagesResponse.status,
      statusText: pagesResponse.statusText,
      headers: new Headers(pagesResponse.headers)
    });
    
    // Add tracking headers (metadata only)
    response.headers.set('X-Webzyl-Property', slug);
    response.headers.set('X-Webzyl-Served-By', 'worker-router');
    
    // Preserve or enhance caching
    if (!response.headers.has('Cache-Control')) {
      response.headers.set('Cache-Control', 'public, max-age=300');
    }
    
    console.log(`[FORWARD] Success: ${pagesResponse.status}`);
    
    return response;
    
  } catch (error) {
    console.error(`[FORWARD] Error:`, error);
    return new Response('Error loading property website', { status: 502 });
  }
}

// ============================================================================
// ERROR RESPONSES (Branded, user-friendly)
// ============================================================================

function propertyNotFoundResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Not Found</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #ef4444; }
      </style>
    </head>
    <body>
      <h1>Property Not Found</h1>
      <p>The property "<strong>${slug}</strong>" does not exist on Webzyl.</p>
      <p><a href="https://webzyl.com">Return to Homepage</a></p>
    </body>
    </html>
  `, {
    status: 404,
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyDeletedResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Removed</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #8b5cf6; }
      </style>
    </head>
    <body>
      <h1>Property Removed</h1>
      <p>This property is no longer available.</p>
      <p>If you believe this is an error, please contact support.</p>
    </body>
    </html>
  `, {
    status: 410, // 410 Gone (better for SEO than 404)
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyInactiveResponse(slug, status) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Inactive</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #f59e0b; }
      </style>
    </head>
    <body>
      <h1>Property Temporarily Unavailable</h1>
      <p>This property is currently inactive (status: ${status}).</p>
      <p>Please contact the property owner for more information.</p>
    </body>
    </html>
  `, {
    status: 403,
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyMaintenanceResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Under Maintenance</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #06b6d4; }
      </style>
    </head>
    <body>
      <h1>ðŸ”§ Under Maintenance</h1>
      <p>This property is temporarily undergoing maintenance.</p>
      <p>Please check back shortly!</p>
    </body>
    </html>
  `, {
    status: 503,
    headers: { 
      'Content-Type': 'text/html',
      'Retry-After': '3600' // Suggest retry after 1 hour
    }
  });
}

// ============================================================================
// OPERATOR DASHBOARD APIs (From v6.3.0 - Unchanged)
// ============================================================================

async function handleOperatorLogin(request, env) {
  try {
    const url = new URL(request.url);
    const slug = url.searchParams.get('slug');
    
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    console.log(`[OPERATOR] Login successful for ${slug}`);
    
    return jsonResponse({
      success: true,
      slug: slug,
      config: config
    });
    
  } catch (error) {
    console.error('[OPERATOR] Login error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorDashboard(slug, env) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    const stats = {
      total_bookings: 0,
      this_month: 0,
      quota_whatsapp_percent: calculateQuotaPercent(
        config.quota_whatsapp_used || 0,
        config.quota_whatsapp_monthly || 0
      ),
      quota_sms_percent: calculateQuotaPercent(
        config.quota_sms_used || 0,
        config.quota_sms_monthly || 0
      )
    };
    
    console.log(`[OPERATOR] Dashboard data for ${slug}`);
    
    return jsonResponse({
      property: config,
      stats: stats,
      bookings: [],
      quota: {
        whatsapp_used: config.quota_whatsapp_used || 0,
        whatsapp_limit: config.quota_whatsapp_monthly || 0,
        sms_used: config.quota_sms_used || 0,
        sms_limit: config.quota_sms_monthly || 0,
        current_month: config.quota_used_month || new Date().toISOString().substring(0, 7)
      }
    });
    
  } catch (error) {
    console.error('[OPERATOR] Dashboard error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorUpdate(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const updates = await request.json();
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    if (updates.name) config.name = updates.name;
    if (updates.tagline) config.tagline = updates.tagline;
    if (updates.about) config.about = updates.about;
    
    if (updates.contact) {
      config.contact = {
        ...config.contact,
        ...updates.contact
      };
    }
    
    config.updatedAt = new Date().toISOString();
    
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[OPERATOR] Updated config for ${slug}`);
    
    return jsonResponse({
      success: true,
      message: 'Property updated successfully',
      config: config
    });
    
  } catch (error) {
    console.error('[OPERATOR] Update error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorBookings(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '10');
    
    const bookings = [];
    
    console.log(`[OPERATOR] Fetched bookings for ${slug}`);
    
    return jsonResponse({
      bookings: bookings,
      total: bookings.length,
      limit: limit
    });
    
  } catch (error) {
    console.error('[OPERATOR] Bookings error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleGalleryUpload(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    console.log(`[OPERATOR] Gallery upload for ${slug}`);
    
    return jsonResponse({
      success: true,
      message: 'ImageKit integration coming soon',
      url: 'https://placeholder.com/image.jpg'
    });
    
  } catch (error) {
    console.error('[OPERATOR] Upload error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleGalleryUpdate(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const { gallery } = await request.json();
    
    if (!Array.isArray(gallery)) {
      return jsonResponse({ error: 'Gallery must be an array' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    config.gallery_json = JSON.stringify(gallery);
    config.updatedAt = new Date().toISOString();
    
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[OPERATOR] Gallery updated for ${slug}`);
    
    return jsonResponse({
      success: true,
      message: 'Gallery updated successfully',
      gallery: gallery
    });
    
  } catch (error) {
    console.error('[OPERATOR] Gallery update error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

// ============================================================================
// DATA REQUEST HANDLER (NEW - for Pages JavaScript)
// ============================================================================

/**
 * Handle data requests for Pages JavaScript
 * Serves config as JSON for client-side rendering
 * Route: /data/:slug.json
 */
async function handleDataRequest(slug, env) {
  try {
    if (!slug || !VALID_SLUG_PATTERN.test(slug)) {
      return jsonResponse({ error: 'Invalid slug' }, 400);
    }

    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });

    if (!config) {
      console.log(`[DATA] Config not found: ${slug}`);
      return jsonResponse({ error: 'Property not found' }, 404);
    }

    // Check status
    if (config.status !== 'active') {
      console.log(`[DATA] Property inactive: ${slug}`);
      return jsonResponse({ error: 'Property inactive' }, 403);
    }

    console.log(`[DATA] Served config for: ${slug}`);
    
    // Return config with CORS headers (jsonResponse includes them)
    return jsonResponse(config);

  } catch (error) {
    console.error('[DATA] Error:', error);
    return jsonResponse({ error: 'Internal server error' }, 500);
  }
}

// ============================================================================
// EXISTING FUNCTIONS (v6.2.2 compatibility - Unchanged)
// ============================================================================

async function handlePublish(request, env) {
  try {
    const token = request.headers.get('X-Publish-Token');
    const expectedToken = env.PUBLISH_SECRET || 'MyVeryLongSecret123!';
    
    if (!token || token !== expectedToken) {
      console.log('[PUBLISH] Unauthorized: Invalid token');
      return jsonResponse({ success: false, error: 'unauthorized' }, 401);
    }
    
    const body = await request.json();
    const { slug, config } = body;
    
    if (!slug || !config) {
      console.log('[PUBLISH] Missing slug or config');
      return jsonResponse({ success: false, error: 'missing_slug_or_config' }, 400);
    }
    
    const configKey = `config:${slug}`;
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[PUBLISH] âœ… Published config for ${slug}`);
    
    if (config.showInMarket) {
      const summary = {
        slug: config.slug,
        name: config.name,
        tagline: config.tagline,
        category: config.category,
        city: config.location?.city,
        state: config.location?.state,
        basePrice: config.basePrice,
        rating: config.rating,
        heroImage: config.branding?.heroImage,
        tags: config.tags
      };
      
      const summaryKey = `market:summary:${slug}`;
      await env.RESORT_CONFIGS.put(summaryKey, JSON.stringify(summary));
      
      console.log(`[PUBLISH] âœ… Added ${slug} to marketplace`);
    }
    
    return jsonResponse({ 
      success: true,
      slug: slug,
      message: 'Configuration published successfully'
    });
    
  } catch (error) {
    console.error('[PUBLISH] Error:', error);
    return jsonResponse({ 
      success: false, 
      error: 'internal_error',
      message: error.message 
    }, 500);
  }
}

async function handleGetConfig(slug, env) {
  try {
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      console.log(`[CONFIG] Not found: ${slug}`);
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    console.log(`[CONFIG] Retrieved: ${slug}`);
    return jsonResponse(config);
    
  } catch (error) {
    console.error('[CONFIG] Error:', error);
    return jsonResponse({ error: 'internal_error' }, 500);
  }
}

async function handleWebsiteSSR(slug, env) {
  try {
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return new Response('Property not found', { status: 404 });
    }
    
    // FIX: Use router pattern (forward, don't redirect)
    // This maintains consistency with subdomain routing
    // Creates single canonical URL experience
    const fakeRequest = new Request(`https://webzyl-worker.example.com/s/${slug}`);
    return await forwardToPages(slug, '', fakeRequest, env);
    
  } catch (error) {
    console.error('[SSR] Error:', error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

// ============================================================================
// UTILITIES
// ============================================================================

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    }
  });
}

function calculateQuotaPercent(used, limit) {
  if (limit === 0) return 0;
  return Math.round((used / limit) * 100);
}

// ============================================================================
// CEO DASHBOARD HANDLERS (v7.0)
// ============================================================================

/**
 * Generate property config from basic input (Template-based)
 */
async function handleCEOGenerate(request, env) {
  try {
    const input = await request.json();
    
    // Validate required fields
    if (!input.name || !input.phone || !input.whatsapp || !input.email || !input.city || !input.state) {
      return jsonResponse({ status: 'error', message: 'Missing required fields' }, 400);
    }
    
    // Generate slug
    const slug = input.slug || generateSlug(input.name);
    
    // Check slug availability
    const existing = await env.RESORT_CONFIGS.get(`config:${slug}`);
    if (existing) {
      return jsonResponse({ status: 'error', message: `Slug '${slug}' already exists. Try: ${slug}-${input.city.toLowerCase()}` }, 400);
    }
    
    // Generate full config using template
    const config = generatePropertyTemplate(input, slug);
    
    console.log(`[CEO] Generated config for: ${slug}`);
    
    return jsonResponse({
      status: 'ok',
      config: config
    });
    
  } catch (error) {
    console.error('[CEO] Generate error:', error);
    return jsonResponse({ status: 'error', message: error.message }, 500);
  }
}

/**
 * Enhance property config with AI (Gemini)
 */
async function handleCEOEnhance(request, env) {
  try {
    const { config } = await request.json();
    
    if (!config) {
      return jsonResponse({ status: 'error', message: 'Config required' }, 400);
    }
    
    // Enhance with Gemini AI
    const enhanced = await enhanceWithGemini(config, env);
    
    console.log(`[CEO] Enhanced config for: ${config.slug}`);
    
    return jsonResponse({
      status: 'ok',
      config: enhanced
    });
    
  } catch (error) {
    console.error('[CEO] Enhance error:', error);
    return jsonResponse({ status: 'error', message: error.message }, 500);
  }
}

/**
 * Publish property to KV
 */
async function handleCEOPublish(request, env) {
  try {
    const { config } = await request.json();
    
    if (!config || !config.slug) {
      return jsonResponse({ status: 'error', message: 'Invalid config' }, 400);
    }
    
    // Add timestamp
    config.updatedAt = new Date().toISOString();
    
    // Write to KV
    const configKey = `config:${config.slug}`;
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    // Create market summary
    const marketSummary = {
      slug: config.slug,
      name: config.name,
      tagline: config.tagline,
      category: config.category,
      city: config.city,
      state: config.state,
      basePrice: config.base_price,
      rating: config.rating,
      heroImage: config.hero_image || '',
      tags: config.tags
    };
    
    await env.RESORT_CONFIGS.put(
      `market:summary:${config.slug}`,
      JSON.stringify(marketSummary)
    );
    
    // Update index (prepend new slug to front)
    const indexData = await env.RESORT_CONFIGS.get('ceo:properties:index', { type: 'json' });
    let slugs = indexData?.slugs || [];
    
    // Remove if exists (update case)
    slugs = slugs.filter(s => s !== config.slug);
    
    // Add to front
    slugs.unshift(config.slug);
    
    // Keep max 1000 in index
    slugs = slugs.slice(0, 1000);
    
    await env.RESORT_CONFIGS.put('ceo:properties:index', JSON.stringify({
      slugs: slugs,
      updatedAt: new Date().toISOString()
    }));
    
    console.log(`[CEO] Published: ${config.slug}`);
    
    return jsonResponse({
      status: 'ok',
      message: 'Property published successfully',
      url: `https://${config.slug}.webzyl.com`
    });
    
  } catch (error) {
    console.error('[CEO] Publish error:', error);
    return jsonResponse({ status: 'error', message: error.message }, 500);
  }
}

/**
 * Get all properties (for dashboard list)
 * Uses index key for performance
 */
async function handleCEOProperties(env) {
  try {
    // Try to get from index first (fast path)
    const indexData = await env.RESORT_CONFIGS.get('ceo:properties:index', { type: 'json' });
    
    if (indexData && Array.isArray(indexData.slugs)) {
      // Fast path: use index
      const properties = [];
      
      // Fetch only the slugs in index (max 50 most recent)
      const slugsToFetch = indexData.slugs.slice(0, 50);
      
      for (const slug of slugsToFetch) {
        const config = await env.RESORT_CONFIGS.get(`config:${slug}`, { type: 'json' });
        if (config) {
          properties.push({
            slug: config.slug,
            name: config.name,
            status: config.status,
            city: config.city || config.location?.city || '',
            state: config.state || config.location?.state || '',
            updatedAt: config.updatedAt
          });
        }
      }
      
      return jsonResponse({
        status: 'ok',
        properties: properties
      });
    }
    
    // Fallback: full scan (slow path - only runs once to build index)
    console.log('[CEO] Index not found, performing full scan');
    const list = await env.RESORT_CONFIGS.list({ prefix: 'config:' });
    
    const properties = [];
    const indexSlugs = [];
    
    for (const key of list.keys) {
      if (key.name.startsWith('config:') && !key.name.includes(':test')) {
        const config = await env.RESORT_CONFIGS.get(key.name, { type: 'json' });
        if (config) {
          properties.push({
            slug: config.slug,
            name: config.name,
            status: config.status,
            city: config.city || config.location?.city || '',
            state: config.state || config.location?.state || '',
            updatedAt: config.updatedAt
          });
          indexSlugs.push(config.slug);
        }
      }
    }
    
    // Sort by most recent
    properties.sort((a, b) => {
      return new Date(b.updatedAt) - new Date(a.updatedAt);
    });
    
    // Create index for next time
    await env.RESORT_CONFIGS.put('ceo:properties:index', JSON.stringify({
      slugs: indexSlugs,
      updatedAt: new Date().toISOString()
    }));
    
    return jsonResponse({
      status: 'ok',
      properties: properties.slice(0, 10)
    });
    
  } catch (error) {
    console.error('[CEO] Properties list error:', error);
    return jsonResponse({ status: 'error', message: error.message }, 500);
  }
}

// ============================================================================
// CEO HELPER FUNCTIONS
// ============================================================================

/**
 * Generate slug from name
 */
function generateSlug(name) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 50);
}

/**
 * Generate property template (smart defaults)
 */
function generatePropertyTemplate(input, slug) {
  const now = new Date().toISOString();
  
  // Extract plan quotas
  const planQuotas = {
    starter: { whatsapp: 20, sms: 0, price: 0 },
    professional: { whatsapp: 50, sms: 0, price: 199 },
    enterprise: { whatsapp: 200, sms: 50, price: 499 }
  };
  
  const plan = input.plan_tier || 'professional';
  const quota = planQuotas[plan];
  
  // Generate basic description if not provided
  const about = input.description || 
    `${input.name} is located in ${input.city}, ${input.state}. A wonderful place to stay and experience the local hospitality.`;
  
  // Generate tagline
  const tagline = `Experience ${input.name}`;
  
  // Parse tags if provided
  const tags = input.tags ? input.tags.split('|').map(t => t.trim()) : [];
  
  return {
    // Core Identity
    slug: slug,
    name: input.name,
    tagline: tagline,
    category: input.category || 'homestay',
    show_in_market: true,
    priority_rank: 10,
    status: 'active',
    template_id: 'resort_v1',
    
    // Branding
    primary_color: '#14b8a6',
    logo_url: '',
    hero_image: '',
    
    // Content
    about: about,
    notes: `Created via CEO Dashboard on ${now}`,
    
    // Location
    address: input.address || `${input.city}, ${input.state}`,
    city: input.city,
    state: input.state,
    country: 'India',
    lat: 0,
    lng: 0,
    map_link: '',
    
    // Pricing
    base_price: parseFloat(input.base_price) || 2000,
    rating: 4.5,
    tags: tags,
    
    // Contact
    contact_name: input.contact_name || 'Property Owner',
    contact_phone: input.phone.replace(/\D/g, ''),
    contact_email: input.email,
    
    // Booking
    booking_mode: 'sheet',
    booking_sheet: `Bookings_${new Date().getFullYear()}_${(new Date().getMonth() + 1).toString().padStart(2, '0')}`,
    whatsapp_template: 'Booking request via WhatsApp',
    
    // Data (empty for now)
    gallery_json: [],
    rooms_json: [],
    amenities_json: [],
    social_json: {},
    
    // Embeds
    embeds_youtube: '',
    embeds_map: '',
    
    // Domain
    custom_domain: '',
    subdomain_enabled: true,
    
    // Notifications
    notify_owner: true,
    notify_customer: true,
    owner_whatsapp: input.whatsapp,
    owner_email: input.email,
    notification_language: 'en',
    max_notifications_hour: 10,
    
    // Payment
    payment_enabled: false,
    payment_provider: null,
    payment_mode: 'disabled',
    payment_currency: 'INR',
    payment_deposit_percent: 30,
    payment_test_mode: true,
    
    // Subscription
    plan_tier: plan,
    plan_price: quota.price,
    trial_started: '',
    trial_ends: '',
    plan_expiry: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    
    // Quotas
    quota_whatsapp_monthly: quota.whatsapp,
    quota_sms_monthly: quota.sms,
    quota_used_month: `${new Date().getFullYear()}-${(new Date().getMonth() + 1).toString().padStart(2, '0')}`,
    quota_whatsapp_used: 0,
    quota_sms_used: 0,
    
    // Metadata
    updatedAt: now
  };
}

/**
 * Enhance config with Gemini AI (v2.1 with field validation)
 */
async function enhanceWithGemini(config, env) {
  try {
    const prompt = `You are a professional copywriter for hospitality businesses.

Given this property:
Name: ${config.name}
Location: ${config.city}, ${config.state}
Category: ${config.category}
Current Description: ${config.about}

Generate:
1. A compelling 10-word tagline that captures the essence
2. A 60-word "About" description that is engaging and professional
3. List 6 relevant amenities that such a ${config.category} would typically have

Return ONLY valid JSON in this exact format (no markdown, no backticks):
{
  "tagline": "your tagline here",
  "about": "your description here",
  "amenities": ["amenity1", "amenity2", "amenity3", "amenity4", "amenity5", "amenity6"]
}`;

    const response = await fetch(
      'https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent?key=' + env.GEMINI_API_KEY,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 1000
          }
        })
      }
    );

    const data = await response.json();
    
    if (!data.candidates || !data.candidates[0]) {
      throw new Error('No AI response received');
    }

    const aiText = data.candidates[0].content.parts[0].text;
    
    // Clean and parse JSON
    const cleaned = aiText.replace(/```json\n?|```\n?/g, '').trim();
    const enhanced = JSON.parse(cleaned);
    
    // =====================================================
    // FIELD-LEVEL VALIDATION & SAFE MERGE
    // =====================================================
    
    // Validate and merge tagline
    if (enhanced.tagline && 
        typeof enhanced.tagline === 'string' && 
        enhanced.tagline.length > 5 && 
        enhanced.tagline.length < 200) {
      config.tagline = enhanced.tagline;
      console.log('[CEO] AI enhanced tagline');
    } else {
      console.warn('[CEO] AI tagline invalid, keeping template');
    }
    
    // Validate and merge about
    if (enhanced.about && 
        typeof enhanced.about === 'string' && 
        enhanced.about.length > 20 && 
        enhanced.about.length < 1000) {
      config.about = enhanced.about;
      console.log('[CEO] AI enhanced about');
    } else {
      console.warn('[CEO] AI about invalid, keeping template');
    }
    
    // Validate and merge amenities
    if (Array.isArray(enhanced.amenities) && 
        enhanced.amenities.length > 0 && 
        enhanced.amenities.length <= 20 &&
        enhanced.amenities.every(a => typeof a === 'string' && a.length > 0 && a.length < 100)) {
      config.amenities_json = enhanced.amenities;
      console.log('[CEO] AI enhanced amenities');
    } else {
      console.warn('[CEO] AI amenities invalid, keeping template');
    }
    
    console.log('[CEO] AI enhancement completed successfully');
    
    return config;
    
  } catch (error) {
    console.error('[CEO] AI enhancement error:', error);
    console.log('[CEO] Falling back to template values');
    // Return original config unchanged if AI fails
    return config;
  }
}
