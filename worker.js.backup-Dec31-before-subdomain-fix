/**
 * WEBZYL WORKER v7.2 - UNIVERSAL SYSTEM (Surgical Update)
 * 
 * NEW in v7.2:
 * - Universal business type support (homestay, restaurant, shop, services, etc.)
 * - Exact mountview config structure (nested objects)
 * - 8 pre-built themes
 * - Universal categories with "Others" option
 * - Updated pricing plans (Basic/Premium/Professional/Enterprise)
 * - Sheet sync hooks (feature-flagged for Phase 1.5)
 * 
 * PRESERVED from v7.1:
 * - All operator endpoints (login, dashboard, update, bookings, gallery)
 * - Subdomain routing
 * - Data endpoints
 * - Booking API integration
 * - CORS handling
 * 
 * Architectural Principles:
 * 1. Worker is a ROUTER, not an HTML processor
 * 2. KV is the authoritative source of truth
 * 3. Pages is the rendering service
 * 4. Keep coupling loose, complexity low
 */

import { handleBookingRequest } from './Booking_Enquiry/files/booking-api.js';

// =====================================================
// CONFIGURATION CONSTANTS
// =====================================================

const RESERVED_SUBDOMAINS = [
  'www', 'api', 'admin', 'operator', 'dashboard',
  'app', 'cdn', 'assets', 'static', 'staging', 'dev', 'img'
];

const VALID_SLUG_PATTERN = /^[a-z0-9-]{3,30}$/;

// 8 Pre-built Themes (NEW in v7.2)
const THEMES = {
  'ocean-breeze': {
    name: 'Ocean Breeze',
    primary: '#14b8a6',
    accent: '#f59e0b'
  },
  'royal-purple': {
    name: 'Royal Purple',
    primary: '#8b5cf6',
    accent: '#ec4899'
  },
  'sky-blue': {
    name: 'Sky Blue',
    primary: '#3b82f6',
    accent: '#06b6d4'
  },
  'fresh-mint': {
    name: 'Fresh Mint',
    primary: '#10b981',
    accent: '#84cc16'
  },
  'sunset-orange': {
    name: 'Sunset Orange',
    primary: '#f97316',
    accent: '#eab308'
  },
  'fiery-red': {
    name: 'Fiery Red',
    primary: '#ef4444',
    accent: '#f59e0b'
  },
  'modern-gray': {
    name: 'Modern Gray',
    primary: '#6b7280',
    accent: '#14b8a6'
  },
  'cherry-blossom': {
    name: 'Cherry Blossom',
    primary: '#ec4899',
    accent: '#f97316'
  }
};

// Universal Categories (NEW in v7.2)
const CATEGORIES = [
  'homestay', 'resort', 'hotel', 'villa', 'cottage',
  'restaurant', 'cafe', 'shop', 'services', 'others'
];

// Pricing Plans (UPDATED in v7.2)
const PRICING_PLANS = {
  basic: {
    name: 'Basic',
    price: 99,
    whatsapp_quota: 20,
    sms_quota: 0
  },
  premium: {
    name: 'Premium',
    price: 199,
    whatsapp_quota: 50,
    sms_quota: 0
  },
  professional: {
    name: 'Professional',
    price: 499,
    whatsapp_quota: 200,
    sms_quota: 0
  },
  enterprise: {
    name: 'Enterprise',
    price: 999,
    whatsapp_quota: 9999,
    sms_quota: 0
  }
};

// Category Default Prices (NEW in v7.2)
const CATEGORY_PRICES = {
  homestay: 1500,
  resort: 5000,
  hotel: 3000,
  villa: 8000,
  cottage: 2000,
  restaurant: 500,
  cafe: 200,
  shop: 0,
  services: 0,
  others: 0
};

// =====================================================
// MEDIA STORAGE CONSTANTS (NEW in v7.3)
// =====================================================

// Image resize widths (fixed, no arbitrary resizing)
const ALLOWED_WIDTHS = [320, 640, 1024, 1600];

// Maximum file sizes by media type (in bytes)
const MAX_SIZES = {
  logo: 5 * 1024 * 1024,      // 5 MB
  gallery: 50 * 1024 * 1024,  // 50 MB
  product: 20 * 1024 * 1024   // 20 MB
};

// Allowed MIME types for uploads
const ALLOWED_CONTENT_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/gif'
];

// Image quota limits by plan tier
const QUOTA_LIMITS = {
  trial: {
    logo: 1,
    gallery: 5,
    product: 0
  },
  basic: {
    logo: 1,
    gallery: 10,
    product: 5
  },
  premium: {
    logo: 1,
    gallery: 25,
    product: 15
  },
  professional: {
    logo: 3,
    gallery: 50,
    product: 40
  },
  enterprise: {
    logo: 5,
    gallery: 100,
    product: 80
  }
};

// =====================================================
// MAIN ROUTER
// =====================================================

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const hostname = url.hostname;
    const path = url.pathname;
    
    // =====================================================
    // SPECIAL HANDLING FOR IMG SUBDOMAIN (Check FIRST - highest priority)
    // =====================================================
    
    // Special handling for img subdomain - serve images directly
    if (hostname === 'img.webzyl.com' || hostname.startsWith('img.')) {
      // Rewrite path to add /img prefix
      const rewrittenUrl = new URL(request.url);
      rewrittenUrl.pathname = '/img' + path;
      const rewrittenRequest = new Request(rewrittenUrl.toString(), request);
      return handleMediaServe(rewrittenRequest, env);
    }
    
    // =====================================================
    // IMAGE SERVING (Check FIRST - highest priority)
    // =====================================================
    
    if (path.startsWith('/img/')) {
      return handleMediaServe(request, env);
    }
    
    // =====================================================
    // DATA ENDPOINT (Critical: Check BEFORE subdomain routing)
    // =====================================================
    
    if (path.startsWith('/data/') && path.endsWith('.json')) {
      const slug = path.split('/')[2].replace('.json', '');
      console.log(`[DATA] Request for: ${slug}`);
      return handleDataRequest(slug, env);
    }
    
    // =====================================================
    // SUBDOMAIN ROUTING (Uses same SSR as /s/ path)
    // =====================================================
    
    const propertySlug = extractPropertySlug(hostname);
    
    if (propertySlug) {
      console.log(`[SUBDOMAIN] Detected property: ${propertySlug}`);
      
      const config = await env.RESORT_CONFIGS.get(`config:${propertySlug}`, { type: 'json' });
      
      if (!config || config.status !== 'active') {
        return new Response('Property not found', { status: 404 });
      }
      
      const template = await env.RESORT_CONFIGS.get('template:smart-nav', { 
        type: 'text'
      });
      
      if (!template) {
        return new Response('Template not configured. Please upload template to KV.', { status: 500 });
      }
      
      const html = renderSmartTemplate(config, template);
      
      return new Response(html, {
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
    }
    
    // =====================================================
    // CORS PREFLIGHT
    // =====================================================
    
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        status: 204,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-CEO-Token',
          'Access-Control-Max-Age': '86400'
        }
      });
    }
    
    // =====================================================
    // OPERATOR DASHBOARD APIs (Preserved from v7.1)
    // =====================================================
    
    if (path === '/api/operator/login' && request.method === 'GET') {
      return handleOperatorLogin(request, env);
    }
    
    if (path.startsWith('/api/operator/dashboard/')) {
      const operatorSlug = path.split('/')[4];
      return handleOperatorDashboard(operatorSlug, env);
    }
    
    if (path.startsWith('/api/operator/update/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[4];
      return handleOperatorUpdate(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/bookings/')) {
      const operatorSlug = path.split('/')[4];
      return handleOperatorBookings(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/gallery/upload/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[5];
      return handleGalleryUpload(request, env, operatorSlug);
    }
    
    if (path.startsWith('/api/operator/gallery/update/') && request.method === 'POST') {
      const operatorSlug = path.split('/')[5];
      return handleGalleryUpdate(request, env, operatorSlug);
    }
    
    // =====================================================
    // LEGACY APIs (Compatibility)
    // =====================================================
    
    if (path === '/api/admin/publish' && request.method === 'POST') {
      return handlePublish(request, env);
    }
    
    if (path.startsWith('/api/config/')) {
      const configSlug = path.split('/').pop();
      return handleGetConfig(configSlug, env);
    }
    
    if (path === '/api/booking') {
      return handleBookingRequest(request, env, ctx);
    }
    
    // =====================================================
    // MEDIA UPLOAD ROUTES (NEW in v7.3)
    // =====================================================
    
    if (path === '/api/media/sign-upload' && request.method === 'POST') {
      return handleMediaSignUpload(request, env);
    }
    
    if (path === '/api/media/confirm-upload' && request.method === 'POST') {
      return handleMediaConfirmUpload(request, env);
    }
    
    if (path.startsWith('/api/media/assets/') && request.method === 'DELETE') {
      const assetId = path.split('/')[4];
      return handleMediaDelete(request, env, assetId);
    }
    
    if (path === '/api/media/assets' && request.method === 'GET') {
      return handleMediaList(request, env);
    }
    
    // =====================================================
    // CEO DASHBOARD APIs (v7.2 - Updated Routes)
    // =====================================================
    
    function validateCEOToken(request, env) {
      const token = request.headers.get('X-CEO-Token');
      if (!token || token !== env.CEO_TOKEN) {
        return false;
      }
      return true;
    }
    
    if (path === '/api/ceo/property/generate' && request.method === 'POST') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ error: 'Unauthorized' }, 401);
      }
      return handleCEOGenerate(request, env);
    }
    
    if (path === '/api/ceo/property/publish' && request.method === 'POST') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ error: 'Unauthorized' }, 401);
      }
      return handleCEOPublish(request, env);
    }
    
    if (path === '/api/ceo/properties' && request.method === 'GET') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ error: 'Unauthorized' }, 401);
      }
      return handleCEOProperties(env);
    }
    
    if (path.startsWith('/api/ceo/property/') && request.method === 'GET') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ error: 'Unauthorized' }, 401);
      }
      const slug = path.split('/')[4];
      return handleCEOGetProperty(slug, env);
    }
    
    if (path.startsWith('/api/ceo/property/') && request.method === 'DELETE') {
      if (!validateCEOToken(request, env)) {
        return jsonResponse({ error: 'Unauthorized' }, 401);
      }
      const slug = path.split('/')[4];
      return handleCEODeleteProperty(slug, env);
    }
    
    if (path.startsWith('/s/')) {
      const pathname = path;
      const slug = pathname.split('/s/')[1].replace('/', '');
      
      const config = await env.RESORT_CONFIGS.get(`config:${slug}`, { type: 'json' });
      
      if (!config || config.status !== 'active') {
        return new Response('Property not found', { status: 404 });
      }
      
      const template = await env.RESORT_CONFIGS.get('template:smart-nav', { 
        type: 'text'
      });
      
      if (!template) {
        return new Response('Template not configured. Please upload template to KV.', { status: 500 });
      }
      
      const html = renderSmartTemplate(config, template);
      
      return new Response(html, {
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
    }
    
    // Root status
    if (path === '/') {
      return jsonResponse({
        status: 'ok',
        service: 'webzyl-worker',
        version: '7.2-universal',
        architecture: 'worker_as_router',
        features: {
          automatic_subdomains: 'slug.webzyl.com',
          data_endpoints: '/data/:slug.json',
          ceo_dashboard: '/api/ceo/* (token protected, CORS enabled)',
          universal_categories: CATEGORIES.length + ' categories',
          themes: Object.keys(THEMES).length + ' themes',
          operator_dashboard: '/api/operator/*',
          kv_authority: 'config:{slug} is source of truth'
        }
      });
    }
    
    return new Response('Not Found', { status: 404 });
  },

  // =====================================================
  // CRON TRIGGERS (NEW - for media cleanup)
  // =====================================================

  async scheduled(event, env, ctx) {
    try {
      console.log(`[CRON] Triggered: ${event.cron}`);

      // Daily cleanup: 2 AM UTC
      if (event.cron === '0 2 * * *') {
        console.log('[CRON] Running daily asset cleanup...');
        await cleanupDeletedAssets(env);
      }

      // Monthly audit: First day of month, 3 AM UTC
      if (event.cron === '0 3 1 * *') {
        console.log('[CRON] Running monthly orphan audit...');
        await auditOrphanedAssets(env);
      }

      return new Response('Cron job completed', { status: 200 });

    } catch (error) {
      console.error('[CRON] Error:', error);
      return new Response(`Cron error: ${error.message}`, { status: 500 });
    }
  }
};

// ============================================================================
// SUBDOMAIN ROUTING - Core Logic (Preserved from v7.1)
// ============================================================================

function extractPropertySlug(hostname) {
  if (!hostname.endsWith('.webzyl.com')) {
    return null;
  }
  
  if (hostname === 'webzyl.com' || hostname === 'www.webzyl.com') {
    return null;
  }
  
  const subdomain = hostname.split('.')[0];
  if (RESERVED_SUBDOMAINS.includes(subdomain)) {
    return null;
  }
  
  if (!VALID_SLUG_PATTERN.test(subdomain)) {
    return null;
  }
  
  return subdomain;
}

async function handlePropertyRequest(slug, path, request, env) {
  try {
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return propertyNotFoundResponse(slug);
    }
    
    if (config.status === 'deleted') {
      return propertyDeletedResponse(slug);
    }
    
    if (config.status === 'inactive' || config.status === 'suspended') {
      return propertyInactiveResponse(slug, config.status);
    }
    
    if (config.status === 'maintenance') {
      return propertyMaintenanceResponse(slug);
    }
    
    console.log(`[PROPERTY] Routing to Pages: ${slug}${path}`);
    
    return await forwardToPages(slug, path, request, env);
    
  } catch (error) {
    console.error(`[PROPERTY] Error handling ${slug}:`, error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

async function forwardToPages(slug, path, originalRequest, env) {
  try {
    const pagesBaseUrl = 'https://webzyl-sites.pages.dev';
    const pagesUrl = `${pagesBaseUrl}/${slug}${path || ''}`;
    
    console.log(`[FORWARD] ${pagesUrl}`);
    
    const pagesRequest = new Request(pagesUrl, {
      method: originalRequest.method,
      headers: originalRequest.headers,
      body: originalRequest.body,
      redirect: 'follow'
    });
    
    const pagesResponse = await fetch(pagesRequest);
    
    const response = new Response(pagesResponse.body, {
      status: pagesResponse.status,
      statusText: pagesResponse.statusText,
      headers: new Headers(pagesResponse.headers)
    });
    
    response.headers.set('X-Webzyl-Property', slug);
    response.headers.set('X-Webzyl-Served-By', 'worker-router');
    
    if (!response.headers.has('Cache-Control')) {
      response.headers.set('Cache-Control', 'public, max-age=300');
    }
    
    console.log(`[FORWARD] Success: ${pagesResponse.status}`);
    
    return response;
    
  } catch (error) {
    console.error(`[FORWARD] Error:`, error);
    return new Response('Error loading property website', { status: 502 });
  }
}

// ============================================================================
// ERROR RESPONSES (Preserved from v7.1)
// ============================================================================

function propertyNotFoundResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Not Found</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #ef4444; }
      </style>
    </head>
    <body>
      <h1>Property Not Found</h1>
      <p>The property "<strong>${slug}</strong>" does not exist on Webzyl.</p>
      <p><a href="https://webzyl.com">Return to Homepage</a></p>
    </body>
    </html>
  `, {
    status: 404,
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyDeletedResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Removed</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #8b5cf6; }
      </style>
    </head>
    <body>
      <h1>Property Removed</h1>
      <p>This property is no longer available.</p>
      <p>If you believe this is an error, please contact support.</p>
    </body>
    </html>
  `, {
    status: 410,
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyInactiveResponse(slug, status) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Property Inactive</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #f59e0b; }
      </style>
    </head>
    <body>
      <h1>Property Temporarily Unavailable</h1>
      <p>This property is currently inactive (status: ${status}).</p>
      <p>Please contact the property owner for more information.</p>
    </body>
    </html>
  `, {
    status: 403,
    headers: { 'Content-Type': 'text/html' }
  });
}

function propertyMaintenanceResponse(slug) {
  return new Response(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Under Maintenance</title>
      <style>
        body { font-family: system-ui; max-width: 600px; margin: 100px auto; text-align: center; }
        h1 { color: #06b6d4; }
      </style>
    </head>
    <body>
      <h1>ðŸ”§ Under Maintenance</h1>
      <p>This property is temporarily undergoing maintenance.</p>
      <p>Please check back shortly!</p>
    </body>
    </html>
  `, {
    status: 503,
    headers: { 
      'Content-Type': 'text/html',
      'Retry-After': '3600'
    }
  });
}

// ============================================================================
// OPERATOR DASHBOARD APIs (Preserved from v7.1)
// ============================================================================

async function handleOperatorLogin(request, env) {
  try {
    const url = new URL(request.url);
    const slug = url.searchParams.get('slug');
    
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    console.log(`[OPERATOR] Login successful for ${slug}`);
    
    return jsonResponse({
      success: true,
      slug: slug,
      config: config
    });
    
  } catch (error) {
    console.error('[OPERATOR] Login error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorDashboard(slug, env) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    // Handle both flat and nested config structures
    const whatsappUsed = config.quota_whatsapp_used || 0;
    const whatsappLimit = config.quota_whatsapp_monthly || 0;
    const smsUsed = config.quota_sms_used || 0;
    const smsLimit = config.quota_sms_monthly || 0;
    
    const stats = {
      total_bookings: 0,
      this_month: 0,
      quota_whatsapp_percent: calculateQuotaPercent(whatsappUsed, whatsappLimit),
      quota_sms_percent: calculateQuotaPercent(smsUsed, smsLimit)
    };
    
    console.log(`[OPERATOR] Dashboard data for ${slug}`);
    
    return jsonResponse({
      property: config,
      stats: stats,
      bookings: [],
      quota: {
        whatsapp_used: whatsappUsed,
        whatsapp_limit: whatsappLimit,
        sms_used: smsUsed,
        sms_limit: smsLimit,
        current_month: config.quota_used_month || new Date().toISOString().substring(0, 7)
      }
    });
    
  } catch (error) {
    console.error('[OPERATOR] Dashboard error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorUpdate(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const updates = await request.json();
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    // Update allowed fields
    if (updates.name) config.name = updates.name;
    if (updates.tagline) config.tagline = updates.tagline;
    if (updates.about) config.about = updates.about;
    
    // Handle nested contact object (v7.2) or flat structure (v7.1)
    if (updates.contact) {
      if (config.contact) {
        config.contact = { ...config.contact, ...updates.contact };
      } else {
        // Fallback for v7.1 flat structure
        if (updates.contact.name) config.contact_name = updates.contact.name;
        if (updates.contact.phone) config.contact_phone = updates.contact.phone;
        if (updates.contact.email) config.contact_email = updates.contact.email;
      }
    }
    
    // Update arrays (rooms, gallery, amenities)
    if (updates.rooms) config.rooms = updates.rooms;
    if (updates.gallery) config.gallery = updates.gallery;
    if (updates.amenities) config.amenities = updates.amenities;
    if (updates.social) config.social = updates.social;
    
    config.updatedAt = new Date().toISOString();
    
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[OPERATOR] Updated config for ${slug}`);
    
    return jsonResponse({
      success: true,
      message: 'Property updated successfully',
      config: config
    });
    
  } catch (error) {
    console.error('[OPERATOR] Update error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleOperatorBookings(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '10');
    
    const bookings = [];
    
    console.log(`[OPERATOR] Fetched bookings for ${slug}`);
    
    return jsonResponse({
      bookings: bookings,
      total: bookings.length,
      limit: limit
    });
    
  } catch (error) {
    console.error('[OPERATOR] Bookings error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleGalleryUpload(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }

    // Parse form data
    const formData = await request.formData();
    const file = formData.get('file');

    if (!file) {
      return jsonResponse({ error: 'No file provided' }, 400);
    }

    // Validate file type
    if (!ALLOWED_CONTENT_TYPES.includes(file.type)) {
      return jsonResponse({ 
        error: `Invalid file type. Allowed: ${ALLOWED_CONTENT_TYPES.join(', ')}` 
      }, 400);
    }

    // Validate file size (50MB max for gallery)
    if (file.size > MAX_SIZES.gallery) {
      return jsonResponse({ 
        error: `File too large. Max ${MAX_SIZES.gallery / 1024 / 1024}MB` 
      }, 400);
    }

    // Verify tenant exists and is active
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }

    // Generate asset ID and object path
    const assetId = generateRandomId(8);
    const randomHash = generateRandomId(12);
    const sanitizedFilename = file.name.replace(/[^a-zA-Z0-9.-]/g, '_').slice(0, 255);
    const objectPath = `${slug}/gallery/${randomHash}/${sanitizedFilename}`;

    console.log(`[OPERATOR] Gallery upload started for ${slug}: ${assetId}`);

    // Get the file buffer
    const arrayBuffer = await file.arrayBuffer();

    // Upload to R2
    await env.MEDIA_R2.put(objectPath, arrayBuffer, {
      httpMetadata: {
        contentType: file.type
      }
    });

    // Record in database
    await env.MEDIA_DB.prepare(`
      INSERT INTO assets (
        id, tenantId, mediaType, objectPath, filename,
        size, contentType, status, createdAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, 'ready', CURRENT_TIMESTAMP)
    `).bind(assetId, slug, 'gallery', objectPath, sanitizedFilename, file.size, file.type).run();

    // Update quota
    const quotaKey = `quota:${slug}:gallery`;
    const quota = await env.RESORT_CONFIGS.get(quotaKey, 'json') || { used: 0 };
    await env.RESORT_CONFIGS.put(quotaKey, JSON.stringify({
      used: quota.used + 1,
      updatedAt: new Date().toISOString()
    }));

    // Build asset URL
    const baseUrl = `https://img.webzyl.com/${slug}/gallery/${assetId}`;

    console.log(`[OPERATOR] Gallery upload successful for ${slug}: ${assetId}`);

    return jsonResponse({
      success: true,
      message: '1 image uploaded successfully',
      assetId,
      assetUrl: baseUrl,
      filename: sanitizedFilename,
      size: file.size,
      variants: {
        thumbnail: `${baseUrl}?w=320`,
        small: `${baseUrl}?w=640`,
        medium: `${baseUrl}?w=1024`,
        large: `${baseUrl}?w=1600`
      }
    });
    
  } catch (error) {
    console.error('[OPERATOR] Upload error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleGalleryUpdate(request, env, slug) {
  try {
    if (!slug) {
      return jsonResponse({ error: 'Slug is required' }, 400);
    }
    
    const { gallery } = await request.json();
    
    if (!Array.isArray(gallery)) {
      return jsonResponse({ error: 'Gallery must be an array' }, 400);
    }
    
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    // Handle both nested (v7.2) and flat (v7.1) structures
    config.gallery = gallery;
    if (config.gallery_json !== undefined) {
      config.gallery_json = JSON.stringify(gallery);
    }
    config.updatedAt = new Date().toISOString();
    
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[OPERATOR] Gallery updated for ${slug}`);
    
    return jsonResponse({
      success: true,
      message: 'Gallery updated successfully',
      gallery: gallery
    });
    
  } catch (error) {
    console.error('[OPERATOR] Gallery update error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

// ============================================================================
// DATA REQUEST HANDLER (Preserved from v7.1)
// ============================================================================

async function handleDataRequest(slug, env) {
  try {
    if (!slug || !VALID_SLUG_PATTERN.test(slug)) {
      return jsonResponse({ error: 'Invalid slug' }, 400);
    }

    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });

    if (!config) {
      console.log(`[DATA] Config not found: ${slug}`);
      return jsonResponse({ error: 'Property not found' }, 404);
    }

    if (config.status === 'deleted' || config.status === 'inactive') {
      return jsonResponse({ error: 'Property not available' }, 410);
    }

    console.log(`[DATA] Serving config for: ${slug}`);
    return jsonResponse(config);

  } catch (error) {
    console.error(`[DATA] Error:`, error);
    return jsonResponse({ error: 'Internal error' }, 500);
  }
}

// ============================================================================
// LEGACY PUBLISH API (Preserved from v7.1)
// ============================================================================

async function handlePublish(request, env) {
  try {
    const authHeader = request.headers.get('Authorization');
    const expectedToken = env.PUBLISH_TOKEN || env.PUBLISH_SECRET;
    
    if (!authHeader || authHeader !== `Bearer ${expectedToken}`) {
      console.log('[PUBLISH] Unauthorized attempt');
      return jsonResponse({ success: false, error: 'unauthorized' }, 401);
    }
    
    const body = await request.json();
    const { slug, config } = body;
    
    if (!slug || !config) {
      console.log('[PUBLISH] Missing slug or config');
      return jsonResponse({ success: false, error: 'missing_slug_or_config' }, 400);
    }
    
    const configKey = `config:${slug}`;
    await env.RESORT_CONFIGS.put(configKey, JSON.stringify(config));
    
    console.log(`[PUBLISH] âœ… Published config for ${slug}`);
    
    // Handle marketplace summary
    const showInMarket = config.showInMarket !== undefined ? config.showInMarket : config.show_in_market;
    
    if (showInMarket) {
      const city = config.location?.city || config.city || '';
      const state = config.location?.state || config.state || '';
      const heroImage = config.branding?.heroImage || config.hero_image || '';
      
      const summary = {
        slug: config.slug,
        name: config.name,
        tagline: config.tagline,
        category: config.category,
        city: city,
        state: state,
        basePrice: config.basePrice || config.base_price || 0,
        rating: config.rating || 0,
        heroImage: heroImage,
        tags: config.tags || []
      };
      
      const summaryKey = `market:summary:${slug}`;
      await env.RESORT_CONFIGS.put(summaryKey, JSON.stringify(summary));
      
      console.log(`[PUBLISH] âœ… Added ${slug} to marketplace`);
    }
    
    return jsonResponse({ 
      success: true,
      slug: slug,
      message: 'Configuration published successfully'
    });
    
  } catch (error) {
    console.error('[PUBLISH] Error:', error);
    return jsonResponse({ 
      success: false, 
      error: 'internal_error',
      message: error.message 
    }, 500);
  }
}

async function handleGetConfig(slug, env) {
  try {
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      console.log(`[CONFIG] Not found: ${slug}`);
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    console.log(`[CONFIG] Retrieved: ${slug}`);
    return jsonResponse(config);
    
  } catch (error) {
    console.error('[CONFIG] Error:', error);
    return jsonResponse({ error: 'internal_error' }, 500);
  }
}

async function handleWebsiteSSR(slug, env) {
  try {
    const configKey = `config:${slug}`;
    const config = await env.RESORT_CONFIGS.get(configKey, { type: 'json' });
    
    if (!config) {
      return new Response('Property not found', { status: 404 });
    }
    
    const fakeRequest = new Request(`https://webzyl-worker.example.com/s/${slug}`);
    return await forwardToPages(slug, '', fakeRequest, env);
    
  } catch (error) {
    console.error('[SSR] Error:', error);
    return new Response('Internal Server Error', { status: 500 });
  }
}

// ============================================================================
// CEO DASHBOARD HANDLERS (v7.2 - UPDATED WITH NESTED STRUCTURE)
// ============================================================================

async function handleCEOGenerate(request, env) {
  try {
    const input = await request.json();
    
    // Validate required fields
    const required = ['businessName', 'phone', 'whatsapp', 'email', 'city', 'state', 'category', 'theme', 'planTier'];
    for (const field of required) {
      if (!input[field]) {
        return jsonResponse({ error: `Missing required field: ${field}` }, 400);
      }
    }
    
    // Generate slug
    const slug = input.customSlug || generateSlug(input.businessName);
    
    // Check slug availability
    const existing = await env.RESORT_CONFIGS.get(`config:${slug}`);
    if (existing) {
      return jsonResponse({ 
        error: 'Slug already exists', 
        suggestion: `${slug}-${input.city.toLowerCase()}` 
      }, 409);
    }
    
    // Generate config with NESTED structure (v7.2)
    const config = generatePropertyTemplate(input, slug);
    
    // AI enhancement if no description provided
    if (!input.description || input.description.trim() === '') {
      try {
        const aiEnhanced = await enhanceWithGemini(config, env);
        return jsonResponse({
          success: true,
          config: aiEnhanced,
          slug: slug,
          message: 'Property generated with AI enhancements'
        });
      } catch (error) {
        console.error('[CEO] AI enhancement failed:', error);
        // Fall back to template only
        return jsonResponse({
          success: true,
          config: config,
          slug: slug,
          message: 'Property generated (AI enhancement failed, using template)'
        });
      }
    }
    
    console.log(`[CEO] Generated config for: ${slug}`);
    
    return jsonResponse({
      success: true,
      config: config,
      slug: slug,
      message: 'Property generated from template'
    });
    
  } catch (error) {
    console.error('[CEO] Generate error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleCEOPublish(request, env) {
  try {
    const { config, slug } = await request.json();
    
    if (!config || !slug) {
      return jsonResponse({ error: 'Missing config or slug' }, 400);
    }
    
    // Validate slug
    if (!VALID_SLUG_PATTERN.test(slug)) {
      return jsonResponse({ error: 'Invalid slug format' }, 400);
    }
    
    // Add metadata
    config.slug = slug;
    config.updatedAt = new Date().toISOString();
    
    // Write to KV
    await env.RESORT_CONFIGS.put(`config:${slug}`, JSON.stringify(config));
    
    // Update market summary
    const summary = {
      slug: config.slug,
      name: config.name,
      tagline: config.tagline,
      category: config.category,
      city: config.location.city,
      state: config.location.state,
      basePrice: config.basePrice || 0,
      rating: config.rating || 0,
      primaryColor: config.branding.primaryColor,
      heroImage: config.branding.heroImage || '',
      showInMarket: config.showInMarket !== false,
      priorityRank: config.priorityRank || 10
    };
    
    await env.RESORT_CONFIGS.put(`market:summary:${slug}`, JSON.stringify(summary));
    
    // Update index
    const indexData = await env.RESORT_CONFIGS.get('ceo:properties:index', { type: 'json' }) || { slugs: [] };
    let slugs = Array.isArray(indexData.slugs) ? indexData.slugs : [];
    
    slugs = slugs.filter(s => s !== config.slug);
    slugs.unshift(config.slug);
    slugs = slugs.slice(0, 1000);
    
    await env.RESORT_CONFIGS.put('ceo:properties:index', JSON.stringify({
      slugs: slugs,
      updatedAt: new Date().toISOString()
    }));
    
    console.log(`[CEO] Published: ${config.slug}`);
    
    return jsonResponse({
      success: true,
      slug: slug,
      url: `https://${slug}.webzyl.com`,
      operatorDashboard: `https://webzyl-operator.pages.dev/operator-dashboard?slug=${slug}`,
      message: 'Property published successfully'
    });
    
  } catch (error) {
    console.error('[CEO] Publish error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleCEOProperties(env) {
  try {
    const indexData = await env.RESORT_CONFIGS.get('ceo:properties:index', { type: 'json' });
    
    if (indexData && Array.isArray(indexData.slugs)) {
      const properties = [];
      const slugsToFetch = indexData.slugs.slice(0, 50);
      
      for (const slug of slugsToFetch) {
        const config = await env.RESORT_CONFIGS.get(`config:${slug}`, { type: 'json' });
        if (config) {
          // Handle both nested and flat structures
          const city = config.location?.city || config.city || '';
          const state = config.location?.state || config.state || '';
          
          properties.push({
            slug: config.slug,
            name: config.name,
            status: config.status,
            city: city,
            state: state,
            category: config.category,
            planTier: config.plan_tier,
            updatedAt: config.updatedAt
          });
        }
      }
      
      return jsonResponse({
        properties: properties,
        total: properties.length
      });
    }
    
    // Fallback: full scan
    console.log('[CEO] Index not found, performing full scan');
    const list = await env.RESORT_CONFIGS.list({ prefix: 'config:' });
    
    const properties = [];
    const indexSlugs = [];
    
    for (const key of list.keys) {
      if (key.name.startsWith('config:') && !key.name.includes(':test')) {
        const config = await env.RESORT_CONFIGS.get(key.name, { type: 'json' });
        if (config) {
          const city = config.location?.city || config.city || '';
          const state = config.location?.state || config.state || '';
          
          properties.push({
            slug: config.slug,
            name: config.name,
            status: config.status,
            city: city,
            state: state,
            category: config.category,
            planTier: config.plan_tier,
            updatedAt: config.updatedAt
          });
          indexSlugs.push(config.slug);
        }
      }
    }
    
    properties.sort((a, b) => {
      return new Date(b.updatedAt) - new Date(a.updatedAt);
    });
    
    await env.RESORT_CONFIGS.put('ceo:properties:index', JSON.stringify({
      slugs: indexSlugs,
      updatedAt: new Date().toISOString()
    }));
    
    return jsonResponse({
      properties: properties.slice(0, 50),
      total: properties.length
    });
    
  } catch (error) {
    console.error('[CEO] Properties list error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleCEOGetProperty(slug, env) {
  try {
    const config = await env.RESORT_CONFIGS.get(`config:${slug}`, { type: 'json' });
    
    if (!config) {
      return jsonResponse({ error: 'Property not found' }, 404);
    }
    
    return jsonResponse(config);
    
  } catch (error) {
    console.error('[CEO] Get property error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleCEODeleteProperty(slug, env) {
  try {
    await env.RESORT_CONFIGS.delete(`config:${slug}`);
    await env.RESORT_CONFIGS.delete(`market:summary:${slug}`);
    
    const indexData = await env.RESORT_CONFIGS.get('ceo:properties:index', { type: 'json' }) || { slugs: [] };
    const newSlugs = indexData.slugs.filter(s => s !== slug);
    await env.RESORT_CONFIGS.put('ceo:properties:index', JSON.stringify({
      slugs: newSlugs,
      updatedAt: new Date().toISOString()
    }));
    
    return jsonResponse({
      success: true,
      message: 'Property deleted successfully'
    });
    
  } catch (error) {
    console.error('[CEO] Delete error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

// ============================================================================
// SSR RENDERER WITH BUSINESS INTENT (Add this to worker.js)
// ============================================================================

const THEME_COLORS = {
  'ocean-breeze': {
    primary: '#14b8a6',
    primaryDark: '#0d9488',
    primaryLight: '#5eead4'
  },
  'royal-purple': {
    primary: '#8b5cf6',
    primaryDark: '#7c3aed',
    primaryLight: '#a78bfa'
  },
  'sky-blue': {
    primary: '#3b82f6',
    primaryDark: '#2563eb',
    primaryLight: '#60a5fa'
  },
  'fresh-mint': {
    primary: '#10b981',
    primaryDark: '#059669',
    primaryLight: '#34d399'
  },
  'sunset-orange': {
    primary: '#f97316',
    primaryDark: '#ea580c',
    primaryLight: '#fb923c'
  },
  'fiery-red': {
    primary: '#ef4444',
    primaryDark: '#dc2626',
    primaryLight: '#f87171'
  },
  'modern-gray': {
    primary: '#6b7280',
    primaryDark: '#4b5563',
    primaryLight: '#9ca3af'
  },
  'cherry-blossom': {
    primary: '#ec4899',
    primaryDark: '#db2777',
    primaryLight: '#f472b6'
  }
};

function deriveBusinessIntent(category) {
  const intentMap = {
    hospitality: ['homestay', 'resort', 'hotel', 'villa', 'cottage'],
    retail: ['shop', 'cafe', 'restaurant'],
    service: ['services'],
    generic: ['others']
  };
  
  for (const [intent, cats] of Object.entries(intentMap)) {
    if (cats.includes(category)) return intent;
  }
  return 'generic';
}

function getIntentLabels(intent) {
  const labels = {
    hospitality: {
      offerings: 'Our Rooms',
      offeringsMenu: 'Rooms',
      highlights: 'Amenities',
      highlightsMenu: 'Amenities',
      primaryAction: 'Book Your Stay',
      primaryActionWhatsApp: "Hello! I'd like to book a stay at",
      primaryActionIcon: 'ðŸ“…'
    },
    retail: {
      offerings: 'Our Products',
      offeringsMenu: 'Products',
      highlights: 'Features',
      highlightsMenu: 'Features',
      primaryAction: 'Enquire on WhatsApp',
      primaryActionWhatsApp: "Hello! I'm interested in your products at",
      primaryActionIcon: 'ðŸ’¬'
    },
    service: {
      offerings: 'Our Services',
      offeringsMenu: 'Services',
      highlights: 'Why Choose Us',
      highlightsMenu: 'Why Us',
      primaryAction: 'Request a Quote',
      primaryActionWhatsApp: "Hello! I'd like to request a quote from",
      primaryActionIcon: 'ðŸ“‹'
    },
    generic: {
      offerings: 'What We Offer',
      offeringsMenu: 'Offerings',
      highlights: 'Highlights',
      highlightsMenu: 'Highlights',
      primaryAction: 'Get In Touch',
      primaryActionWhatsApp: "Hello! I'd like to know more about",
      primaryActionIcon: 'âœ‰ï¸'
    }
  };
  
  return labels[intent] || labels.generic;
}

function formatPrice(value, unit = '', currencySymbol = 'â‚¹') {
  if (value === undefined || value === null || value === '') {
    return '';
  }
  if (typeof value === 'number') {
    return `${currencySymbol}${value.toLocaleString('en-IN')}${unit ? ` ${unit}` : ''}`;
  }
  const text = String(value).trim();
  const hasCurrency = /â‚¹|\$|rs\.?|inr/i.test(text);
  if (hasCurrency) {
    return text;
  }
  return `${currencySymbol}${text}${unit ? ` ${unit}` : ''}`;
}

function renderSmartTemplate(config, templateHTML) {
  const intent = deriveBusinessIntent(config.category);
  const labels = getIntentLabels(intent);
  const themeId = config.templateId || 'ocean-breeze';
  const themeColors = THEME_COLORS[themeId] || THEME_COLORS['ocean-breeze'];
  const colors = {
    primary: config.branding?.primaryColor || themeColors.primary,
    primaryDark: config.branding?.primaryDark || themeColors.primaryDark,
    primaryLight: config.branding?.primaryLight || themeColors.primaryLight
  };
  
  const has_gallery = Array.isArray(config.gallery) && config.gallery.length > 0;
  const has_offerings = Array.isArray(config.rooms) && config.rooms.length > 0;
  const has_highlights = Array.isArray(config.amenities) && config.amenities.length > 0;
  const has_primary_action = ['hospitality', 'retail', 'service'].includes(intent);
  const has_social = config.social && (config.social.facebook || config.social.instagram || config.social.twitter || config.social.youtube);
  
  let html = templateHTML
    .replace(/{{BUSINESS_NAME}}/g, config.name || '')
    .replace(/{{TAGLINE}}/g, config.tagline || '')
    .replace(/{{DESCRIPTION}}/g, config.about || '')
    .replace(/{{PRIMARY_COLOR}}/g, colors.primary)
    .replace(/{{PRIMARY_DARK}}/g, colors.primaryDark)
    .replace(/{{PRIMARY_LIGHT}}/g, colors.primaryLight)
    .replace(/{{HERO_IMAGE}}/g, config.branding?.heroImage || 'https://images.unsplash.com/photo-1566073771259-6a8506099945')
    .replace(/{{PHONE}}/g, config.contact?.phone || '')
    .replace(/{{EMAIL}}/g, config.contact?.email || '')
    .replace(/{{WHATSAPP}}/g, config.contact?.whatsapp || '')
    .replace(/{{ADDRESS}}/g, config.location?.address || '')
    .replace(/{{MAP_LINK}}/g, config.location?.mapLink || '');
  
  html = html
    .replace(/{{OFFERINGS_LABEL}}/g, labels.offerings)
    .replace(/{{OFFERINGS_MENU_LABEL}}/g, labels.offeringsMenu)
    .replace(/{{HIGHLIGHTS_LABEL}}/g, labels.highlights)
    .replace(/{{HIGHLIGHTS_MENU_LABEL}}/g, labels.highlightsMenu)
    .replace(/{{PRIMARY_ACTION_LABEL}}/g, labels.primaryAction)
    .replace(/{{PRIMARY_ACTION_WHATSAPP}}/g, `${labels.primaryActionWhatsApp} ${config.name}`)
    .replace(/{{PRIMARY_ACTION_ICON}}/g, labels.primaryActionIcon);

  const primaryActionLink = config.contact?.whatsapp
    ? `https://wa.me/${config.contact.whatsapp}?text=${encodeURIComponent(`${labels.primaryActionWhatsApp} ${config.name || ''}`)}`
    : '#contact';
  html = html.replace(/{{PRIMARY_ACTION_LINK}}/g, primaryActionLink);
  
  html = handleConditional(html, 'HAS_GALLERY', has_gallery);
  html = handleConditional(html, 'HAS_OFFERINGS', has_offerings);
  html = handleConditional(html, 'HAS_HIGHLIGHTS', has_highlights);
  html = handleConditional(html, 'HAS_PRIMARY_ACTION', has_primary_action);
  html = handleConditional(html, 'HAS_SOCIAL', has_social);
  
  html = handleConditional(html, 'FACEBOOK', config.social?.facebook);
  html = handleConditional(html, 'INSTAGRAM', config.social?.instagram);
  html = handleConditional(html, 'TWITTER', config.social?.twitter);
  html = handleConditional(html, 'YOUTUBE_SOCIAL', config.social?.youtube);
  html = handleConditional(html, 'MAP_LINK', config.location?.mapLink);
  html = handleConditional(html, 'MAP_EMBED', config.embeds?.map);
  
  if (config.social) {
    html = html.replace(/{{FACEBOOK}}/g, config.social.facebook || '');
    html = html.replace(/{{INSTAGRAM}}/g, config.social.instagram || '');
    html = html.replace(/{{TWITTER}}/g, config.social.twitter || '');
    html = html.replace(/{{YOUTUBE_SOCIAL}}/g, config.social.youtube || '');
  }

  if (config.embeds?.map) {
    html = html.replace(/{{MAP_EMBED}}/g, config.embeds.map);
  }
  
  if (has_gallery) {
    const galleryHTML = config.gallery.map(img => {
      const src = typeof img === 'string' ? img : (img?.url || '');
      if (!src) return '';
      return `
        <div class="gallery-item" onclick="openLightbox('${src}')">
          <img src="${src}" alt="Gallery Image">
        </div>
      `;
    }).filter(Boolean).join('\n');
    html = html.replace(/{{#GALLERY}}[\s\S]*?{{\/GALLERY}}/g, galleryHTML);
  }
  
  if (has_highlights) {
    const highlightsHTML = config.amenities.map(amenity => {
      const name = typeof amenity === 'string' ? amenity : amenity.name;
      const icon = (typeof amenity === 'object' && amenity.icon) ? amenity.icon : 'âœ¨';
      return `
        <div class="amenity-card">
          <div class="amenity-icon">${icon}</div>
          <h3>${name}</h3>
        </div>
      `;
    }).join('\n');
    html = html.replace(/{{#HIGHLIGHTS}}[\s\S]*?{{\/HIGHLIGHTS}}/g, highlightsHTML);
  }
  
  if (has_offerings) {
    const offeringsHTML = config.rooms.map(room => {
      const roomData = typeof room === 'object' ? room : { name: room };
      const priceValue = roomData.price ?? config.basePrice ?? '';
      const priceUnit = roomData.priceUnit || (intent === 'hospitality' ? '/night' : '');
      const priceLabel = formatPrice(priceValue, priceUnit);
      const image = roomData.image || config.branding?.heroImage || 'https://images.unsplash.com/photo-1566073771259-6a8506099945';
      return `
        <div class="card">
          <img src="${image}" alt="${roomData.name || 'Offering'}" class="card-image">
          <div class="card-content">
            <h3 class="card-title">${roomData.name || ''}</h3>
            <p class="card-text">${roomData.description || ''}</p>
            ${priceLabel ? `<p style="font-size: 1.5rem; color: ${colors.primary}; font-weight: 700;">${priceLabel}</p>` : ''}
          </div>
        </div>
      `;
    }).join('\n');
    html = html.replace(/{{#OFFERINGS}}[\s\S]*?{{\/OFFERINGS}}/g, offeringsHTML);
  }
  
  return html;
}

function handleConditional(html, tag, condition) {
  const regex = new RegExp(`{{#${tag}}}([\\s\\S]*?){{\/${tag}}}`, 'g');
  
  if (condition) {
    return html.replace(regex, '$1');
  } else {
    return html.replace(regex, '');
  }
}

// ============================================================================
// TEMPLATE GENERATOR (v7.2 - NESTED STRUCTURE)
// ============================================================================

function generateSlug(name) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .substring(0, 30);
}

function generatePropertyTemplate(input, slug) {
  const theme = THEMES[input.theme] || THEMES['ocean-breeze'];
  const plan = PRICING_PLANS[input.planTier] || PRICING_PLANS.premium;
  
  const expiryDate = new Date();
  expiryDate.setFullYear(expiryDate.getFullYear() + 1);
  
  const now = new Date();
  const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
  
  // Handle custom category for "Others"
  const category = input.category === 'others' ? (input.customCategory || 'others') : input.category;
  
  // Generate defaults
  const tagline = input.tagline || generateDefaultTagline(category, input.businessName);
  const description = input.description || generateDefaultDescription(category, input.businessName, input.city);
  const basePrice = input.basePrice || CATEGORY_PRICES[input.category] || 0;
  
  return {
    // Core identity (camelCase)
    slug: slug,
    name: input.businessName,
    tagline: tagline,
    category: category,
    showInMarket: true,
    priorityRank: 10,
    status: 'active',
    templateId: 'resort_v1',
    
    // Nested branding object
    branding: {
      primaryColor: theme.primary,
      logo: input.logoUrl || '',
      heroImage: input.heroImage || ''
    },
    
    about: description,
    notes: `Created via CEO Dashboard on ${new Date().toISOString()}`,
    
    // Nested location object
    location: {
      address: input.fullAddress || `${input.city}, ${input.state}`,
      mapLink: input.mapLink || '',
      city: input.city,
      state: input.state,
      country: 'India',
      lat: 0,
      lng: 0
    },
    
    tags: [],
    basePrice: basePrice,
    rating: 4.5,
    
    // Nested contact object
    contact: {
      name: input.contactName || 'Owner',
      phone: input.phone,
      email: input.email,
      whatsapp: input.whatsapp
    },
    
    // Nested booking object
    booking: {
      mode: 'sheet',
      sheetName: `Bookings_${now.getFullYear()}_${String(now.getMonth() + 1).padStart(2, '0')}`,
      whatsappTemplate: 'Thank you for your booking request! We will contact you shortly.',
      payment: {
        enabled: false,
        provider: null,
        mode: 'disabled',
        currency: 'INR',
        depositPercent: 30,
        testMode: true
      }
    },
    
    // Nested notifications object
    notifications: {
      enabled: true,
      notifyOwner: true,
      notifyCustomer: true,
      ownerWhatsapp: input.whatsapp,
      ownerEmail: input.email,
      language: 'en',
      maxPerHour: 10
    },
    
    // Plan fields (snake_case)
    plan_tier: input.planTier,
    plan_price: plan.price,
    trial_started: '',
    trial_ends: '',
    plan_expiry: expiryDate.toISOString().split('T')[0],
    
    // Quota fields (snake_case)
    quota_whatsapp_monthly: plan.whatsapp_quota,
    quota_sms_monthly: 0,
    quota_used_month: currentMonth,
    quota_whatsapp_used: 0,
    quota_sms_used: 0,
    
    // Empty arrays for operator to fill later (or filled from input)
    gallery: input.gallery || [],
    rooms: [],
    amenities: input.amenities ? input.amenities.map(a => ({ name: a, icon: 'âœ¨' })) : [],
    social: {
      facebook: input.facebook || '',
      instagram: input.instagram || '',
      twitter: input.twitter || '',
      youtube: input.youtube || ''
    },
    
    embeds: {
      youtube: input.youtubeEmbed || '',
      map: input.mapsEmbed || input.mapLink || ''
    },
    
    customDomain: '',
    subdomainEnabled: true,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
}

function generateDefaultTagline(category, businessName) {
  const taglines = {
    homestay: 'Experience comfort like home',
    resort: 'Your perfect getaway',
    hotel: 'Luxury and comfort combined',
    villa: 'Private paradise awaits',
    cottage: 'Cozy retreat in nature',
    restaurant: 'Delicious food, memorable moments',
    cafe: 'Great coffee, better vibes',
    shop: 'Quality products, trusted service',
    services: 'Professional service you can trust',
    others: 'Quality service for you'
  };
  
  return taglines[category] || `Welcome to ${businessName}`;
}

function generateDefaultDescription(category, businessName, city) {
  const descriptions = {
    homestay: `${businessName} offers comfortable accommodation in ${city}. Experience warm hospitality and a home away from home.`,
    resort: `${businessName} is a premium resort in ${city}, offering world-class amenities and unforgettable experiences.`,
    hotel: `${businessName} provides exceptional hospitality in the heart of ${city}. Modern rooms, excellent service.`,
    villa: `${businessName} is your private villa in ${city}. Spacious, luxurious, and perfect for families or groups.`,
    cottage: `${businessName} offers cozy cottages in ${city}. Perfect for a peaceful retreat surrounded by nature.`,
    restaurant: `${businessName} serves delicious cuisine in ${city}. Fresh ingredients, authentic flavors, and warm ambiance.`,
    cafe: `${businessName} is your favorite cafe in ${city}. Great coffee, tasty snacks, and a welcoming atmosphere.`,
    shop: `${businessName} is your trusted shop in ${city}. Quality products, fair prices, and excellent customer service.`,
    services: `${businessName} provides professional services in ${city}. Reliable, efficient, and customer-focused.`,
    others: `${businessName} is located in ${city}. We offer quality products and services to meet your needs.`
  };
  
  return descriptions[category] || `Welcome to ${businessName} in ${city}.`;
}

// ============================================================================
// AI ENHANCEMENT (Gemini)
// ============================================================================

async function enhanceWithGemini(config, env) {
  try {
    const prompt = `You are a professional content writer for a ${config.category} business.

Business Name: ${config.name}
Category: ${config.category}
Location: ${config.location.city}, ${config.location.state}

Generate a compelling "About" section (2-3 paragraphs, 100-150 words) that:
1. Highlights what makes this ${config.category} special
2. Mentions the location naturally
3. Creates an emotional connection
4. Sounds professional but warm

Return ONLY the description text, no markdown, no labels.`;

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${env.GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 300
          }
        })
      }
    );

    if (!response.ok) {
      throw new Error('AI generation failed');
    }

    const result = await response.json();
    const aiDescription = result.candidates[0]?.content?.parts[0]?.text?.trim();

    if (aiDescription) {
      config.about = aiDescription;
      config.notes += ' | AI-enhanced description';
    }

    return config;
    
  } catch (error) {
    console.error('[AI] Enhancement error:', error);
    // Return original config on error
    return config;
  }
}

// ============================================================================
// UTILITIES
// ============================================================================

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-CEO-Token'
    }
  });
}

function calculateQuotaPercent(used, limit) {
  if (limit === 0) return 0;
  return Math.round((used / limit) * 100);
}

// ============================================================================
// MEDIA STORAGE HANDLERS (NEW in v7.3)
// ============================================================================

async function handleMediaSignUpload(request, env) {
  try {
    const body = await request.json();
    const { tenantId, mediaType, filename, contentType, size } = body;

    if (!tenantId || !mediaType || !filename || !contentType || !size) {
      return jsonResponse({ error: 'Missing required fields' }, 400);
    }

    if (!['logo', 'gallery', 'product'].includes(mediaType)) {
      return jsonResponse({ error: 'Invalid media type' }, 400);
    }

    if (!ALLOWED_CONTENT_TYPES.includes(contentType)) {
      return jsonResponse({ error: 'Unsupported file type' }, 400);
    }

    if (size > MAX_SIZES[mediaType]) {
      return jsonResponse({ 
        error: `File too large. Max ${MAX_SIZES[mediaType] / 1024 / 1024}MB for ${mediaType}` 
      }, 400);
    }

    const systemConfig = await env.RESORT_CONFIGS.get('system:uploads_enabled', 'json');
    if (systemConfig && !systemConfig.enabled) {
      return jsonResponse({ error: 'Uploads temporarily disabled' }, 503);
    }

const tenantConfig = await env.RESORT_CONFIGS.get(`config:${tenantId}`, 'json');
    
    // Allow pre-publish uploads (tenant will be created when property is published)
    if (!tenantConfig) {
      console.log('[MEDIA] Pre-publish upload allowed for: ' + tenantId);
      // Continue without tenant validation - this is a pre-publish upload
    } else if (tenantConfig.status !== 'active') {
      return jsonResponse({ error: 'Tenant inactive' }, 403);
    }

    const lockKey = `upload-lock:${tenantId}`;
    const existing = await env.RESORT_CONFIGS.get(lockKey);
    if (existing) {
      return jsonResponse({ error: 'Upload already in progress' }, 429);
    }

    await env.RESORT_CONFIGS.put(lockKey, JSON.stringify({ lockedAt: new Date().toISOString() }), { expirationTtl: 60 });

    try {
      const plan = tenantConfig?.plan_tier || 'trial';
      const quotaKey = `quota:${tenantId}:${mediaType}`;
      const quota = await env.RESORT_CONFIGS.get(quotaKey, 'json') || { used: 0 };
      const limit = QUOTA_LIMITS[plan]?.[mediaType] || QUOTA_LIMITS.trial[mediaType];

      if (quota.used >= limit) {
        await env.RESORT_CONFIGS.delete(lockKey);
        return jsonResponse({
          error: 'quota_exceeded',
          message: `${mediaType} limit reached (${quota.used}/${limit})`,
          current: quota.used,
          limit
        }, 429);
      }

      const assetId = generateRandomId(8);
      const randomHash = generateRandomId(12);
      const sanitizedFilename = filename.replace(/[^a-zA-Z0-9.-]/g, '_').slice(0, 255);
      const objectPath = `${tenantId}/${mediaType}/${randomHash}/${sanitizedFilename}`;

      await env.MEDIA_DB.prepare(`
        INSERT INTO assets (
          id, tenantId, mediaType, objectPath, filename,
          size, contentType, status, createdAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, 'pending', CURRENT_TIMESTAMP)
      `).bind(assetId, tenantId, mediaType, objectPath, sanitizedFilename, size, contentType).run();

      const uploadUrl = await generatePresignedPutUrl(
        env.R2_ACCOUNT_ID,
        env.R2_ACCESS_KEY_ID,
        env.R2_SECRET_ACCESS_KEY,
        'webzyl-media',
        objectPath,
        contentType,
        14400
      );

      return jsonResponse({
        uploadUrl,
        assetId,
        objectPath,
        expiresAt: new Date(Date.now() + 14400 * 1000).toISOString(),
        headers: { 'Content-Type': contentType, 'X-Content-Hash': 'required' }
      }, 200);

    } catch (error) {
      await env.RESORT_CONFIGS.delete(lockKey);
      throw error;
    }

  } catch (error) {
    console.error('[MEDIA] Sign upload error:', error);
    return jsonResponse({ error: error.message || 'Internal server error' }, 500);
  }
}

async function handleMediaConfirmUpload(request, env) {
  let tenantId = null;
  
  try {
    const body = await request.json();
    const { assetId, contentHash } = body;
    tenantId = body.tenantId;

    if (!assetId || !tenantId) {
      return jsonResponse({ error: 'Missing required fields' }, 400);
    }

    const asset = await env.MEDIA_DB.prepare(`
      SELECT * FROM assets 
      WHERE id = ? AND tenantId = ? AND status = 'pending'
    `).bind(assetId, tenantId).first();

    if (!asset) {
      return jsonResponse({ error: 'Asset not found or already confirmed' }, 404);
    }

    const head = await env.MEDIA_R2.head(asset.objectPath);
    
    if (!head) {
      return jsonResponse({ error: 'Upload not found in storage' }, 404);
    }

    if (head.size !== asset.size) {
      return jsonResponse({ 
        error: `Upload size mismatch: expected ${asset.size}, got ${head.size}` 
      }, 400);
    }

    await env.MEDIA_DB.prepare(`
      UPDATE assets
      SET status = 'ready', contentHash = ?, updatedAt = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(contentHash, assetId).run();

    const quotaKey = `quota:${tenantId}:${asset.mediaType}`;
    const quota = await env.RESORT_CONFIGS.get(quotaKey, 'json') || { used: 0 };
    await env.RESORT_CONFIGS.put(quotaKey, JSON.stringify({
      used: quota.used + 1,
      updatedAt: new Date().toISOString()
    }));

    const baseUrl = `https://img.webzyl.com/${tenantId}/${asset.mediaType}/${assetId}`;

    return jsonResponse({
      success: true,
      assetId,
      assetUrl: baseUrl,
      variants: {
        thumbnail: `${baseUrl}?w=320`,
        small: `${baseUrl}?w=640`,
        medium: `${baseUrl}?w=1024`,
        large: `${baseUrl}?w=1600`
      }
    }, 200);

  } catch (error) {
    console.error('[MEDIA] Confirm upload error:', error);
    return jsonResponse({ error: error.message || 'Internal server error' }, 500);
  } finally {
    if (tenantId) {
      await env.RESORT_CONFIGS.delete(`upload-lock:${tenantId}`);
    }
  }
}

async function handleMediaServe(request, env) {
  try {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(Boolean);

    if (pathParts.length < 4) {
      return new Response('Invalid image path', { status: 400 });
    }

    const [_, tenantId, mediaType, assetId] = pathParts;

    const asset = await env.MEDIA_DB.prepare(`
      SELECT * FROM assets
      WHERE tenantId = ? AND mediaType = ? AND id = ? AND status = 'ready'
    `).bind(tenantId, mediaType, assetId).first();

    if (!asset) {
      return new Response('Image not found', { 
        status: 404,
        headers: { 'Cache-Control': 'public, max-age=60' }
      });
    }

    const requestedWidth = parseInt(url.searchParams.get('w') || '1024');
    const width = clampToAllowedWidth(requestedWidth);

    // Use R2 binding directly instead of public URL
    const r2Object = await env.MEDIA_R2.get(asset.objectPath);
    
    if (!r2Object) {
      console.error(`[MEDIA] R2 object not found: ${asset.objectPath}`);
      return new Response('Image file not found in storage', { status: 404 });
    }

    // Get the image as a blob
    const imageBlob = await r2Object.blob();
    
    // Create a new request for Cloudflare Image Resizing
    const resizeRequest = new Request('https://example.com/image', {
      method: 'POST',
      body: imageBlob,
      headers: {
        'Content-Type': asset.contentType
      }
    });

    // Use Cloudflare's fetch with image resizing
    const imageResponse = await fetch(resizeRequest, {
      cf: {
        image: { 
          width, 
          quality: 85, 
          format: 'auto', 
          metadata: 'none' 
        }
      }
    });

    if (!imageResponse.ok) {
      console.error(`[MEDIA] Image resize failed for: ${asset.objectPath}`);
      // Fallback: return original image without resizing
      return new Response(imageBlob, {
        status: 200,
        headers: {
          'Content-Type': asset.contentType,
          'Cache-Control': 'public, max-age=31536000, immutable',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }

    const headers = new Headers(imageResponse.headers);
    headers.set('Cache-Control', 'public, max-age=31536000, immutable');
    headers.set('CDN-Cache-Control', 'public, max-age=31536000');
    headers.set('Access-Control-Allow-Origin', '*');

    return new Response(imageResponse.body, { 
      status: imageResponse.status,
      headers 
    });

  } catch (error) {
    console.error('[MEDIA] Serve error:', error);
    return new Response('Internal server error', { status: 500 });
  }
}

async function handleMediaDelete(request, env) {
  try {
    const url = new URL(request.url);
    const assetId = url.pathname.split('/').pop();
    const tenantId = request.headers.get('X-Tenant-ID');

    if (!assetId || !tenantId) {
      return jsonResponse({ error: 'Missing asset ID or tenant ID' }, 400);
    }

    const asset = await env.MEDIA_DB.prepare(`
      SELECT * FROM assets WHERE id = ? AND tenantId = ?
    `).bind(assetId, tenantId).first();

    if (!asset) {
      return jsonResponse({ error: 'Asset not found' }, 404);
    }

    await env.MEDIA_DB.prepare(`
      UPDATE assets
      SET status = 'deleted', deletedAt = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(assetId).run();

    const quotaKey = `quota:${tenantId}:${asset.mediaType}`;
    const quota = await env.RESORT_CONFIGS.get(quotaKey, 'json') || { used: 0 };
    await env.RESORT_CONFIGS.put(quotaKey, JSON.stringify({
      used: Math.max(0, quota.used - 1),
      updatedAt: new Date().toISOString()
    }));

    return jsonResponse({
      success: true,
      assetId,
      deletedAt: new Date().toISOString(),
      gracePeriod: '30 days'
    }, 200);

  } catch (error) {
    console.error('[MEDIA] Delete error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

async function handleMediaList(request, env) {
  try {
    const url = new URL(request.url);
    const tenantId = url.searchParams.get('tenantId');
    const mediaType = url.searchParams.get('mediaType');
    const status = url.searchParams.get('status') || 'ready';
    const limit = Math.min(parseInt(url.searchParams.get('limit') || '50'), 100);
    const offset = parseInt(url.searchParams.get('offset') || '0');

    if (!tenantId) {
      return jsonResponse({ error: 'Missing tenant ID' }, 400);
    }

    let query = 'SELECT * FROM assets WHERE tenantId = ? AND status = ?';
    const params = [tenantId, status];

    if (mediaType) {
      query += ' AND mediaType = ?';
      params.push(mediaType);
    }

    query += ' ORDER BY createdAt DESC LIMIT ? OFFSET ?';
    params.push(limit, offset);

    const { results } = await env.MEDIA_DB.prepare(query).bind(...params).all();

    const quotaKey = `quota:${tenantId}:${mediaType || 'gallery'}`;
    const quota = await env.RESORT_CONFIGS.get(quotaKey, 'json') || { used: 0, limit: 5 };

    return jsonResponse({
      assets: results,
      total: results.length,
      limit,
      offset,
      quota
    }, 200);

  } catch (error) {
    console.error('[MEDIA] List error:', error);
    return jsonResponse({ error: error.message }, 500);
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function generateRandomId(length) {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let id = '';
  for (let i = 0; i < length; i++) {
    id += chars[Math.floor(Math.random() * chars.length)];
  }
  return id;
}

function clampToAllowedWidth(width) {
  if (width <= ALLOWED_WIDTHS[0]) return ALLOWED_WIDTHS[0];
  if (width >= ALLOWED_WIDTHS[ALLOWED_WIDTHS.length - 1]) {
    return ALLOWED_WIDTHS[ALLOWED_WIDTHS.length - 1];
  }

  for (let i = 0; i < ALLOWED_WIDTHS.length - 1; i++) {
    const lower = ALLOWED_WIDTHS[i];
    const upper = ALLOWED_WIDTHS[i + 1];
    if (width >= lower && width < upper) {
      const distToLower = width - lower;
      const distToUpper = upper - width;
      return distToLower < distToUpper ? lower : upper;
    }
  }

  return ALLOWED_WIDTHS[1];
}

async function generatePresignedPutUrl(accountId, accessKeyId, secretAccessKey, bucketName, objectKey, contentType, expirySeconds) {
  const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');
  const { getSignedUrl } = await import('@aws-sdk/s3-request-presigner');

  const s3Client = new S3Client({
    region: 'auto',
    endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
    credentials: { accessKeyId, secretAccessKey }
  });

  const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: objectKey,
    ContentType: contentType
  });

  return await getSignedUrl(s3Client, command, { expiresIn: expirySeconds });
}

// ============================================================================
// CRON CLEANUP FUNCTIONS
// ============================================================================

async function cleanupDeletedAssets(env) {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const { results } = await env.MEDIA_DB.prepare(`
    SELECT id, objectPath FROM assets
    WHERE deletedAt IS NOT NULL
      AND deletedAt < ?
      AND status = 'deleted'
    LIMIT 100
  `).bind(thirtyDaysAgo.toISOString()).all();

  for (const asset of results) {
    try {
      await env.MEDIA_R2.delete(asset.objectPath);
      await env.MEDIA_DB.prepare(`
        UPDATE assets SET status = 'permanently_deleted' WHERE id = ?
      `).bind(asset.id).run();
      console.log(`[CRON] Deleted asset: ${asset.id}`);
    } catch (error) {
      console.error(`[CRON] Failed to delete ${asset.id}:`, error);
    }
  }
}

async function auditOrphanedAssets(env) {
  const { results } = await env.MEDIA_DB.prepare(`
    SELECT objectPath FROM assets WHERE status != 'permanently_deleted'
  `).all();

  const knownPaths = new Set(results.map(r => r.objectPath));
  const listed = await env.MEDIA_R2.list({ limit: 1000 });
  const orphans = [];

  for (const object of listed.objects) {
    if (!knownPaths.has(object.key)) {
      orphans.push({ key: object.key, size: object.size });
    }
  }

  if (orphans.length > 0) {
    console.log(`[CRON] Found ${orphans.length} orphaned objects`, orphans);
  }

  if (listed.truncated) {
    console.warn('[CRON] R2 list truncated - pagination required');
  }
}

